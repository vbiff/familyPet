import 'package:test/test.dart';
import 'package:mockito/mockito.dart';

import 'package:fpdart/fpdart.dart' hide Task;
import 'package:jhonny/core/error/failures.dart';
import 'package:jhonny/features/task/domain/entities/task.dart';
import 'package:jhonny/features/task/domain/repositories/task_repository.dart';
import 'package:jhonny/features/task/domain/usecases/update_task_status.dart';

// Mock class (will be generated by build_runner)
class MockTaskRepository extends Mock implements TaskRepository {}

void main() {
  late UpdateTaskStatus usecase;
  late MockTaskRepository mockRepository;

  setUp(() {
    mockRepository = MockTaskRepository();
    usecase = UpdateTaskStatus(mockRepository);
  });

  group('UpdateTaskStatus UseCase', () {
    const String testTaskId = 'task-123';
    final DateTime testCompletedAt = DateTime(2024, 1, 1, 12, 0);
    final DateTime testVerifiedAt = DateTime(2024, 1, 1, 12, 30);
    const String testVerifiedById = 'parent-123';

    final tTask = Task(
      id: testTaskId,
      title: 'Clean Room',
      description: 'Clean and organize your bedroom',
      points: 50,
      status: TaskStatus.completed,
      assignedTo: 'child-1',
      createdBy: 'parent-1',
      dueDate: DateTime(2024, 12, 31),
      frequency: TaskFrequency.weekly,
      familyId: 'family-123',
      imageUrls: const [],
      createdAt: DateTime.now(),
      completedAt: testCompletedAt,
      verifiedAt: testVerifiedAt,
      verifiedById: testVerifiedById,
    );

    test('should update task status successfully when all parameters are valid',
        () async {
      // arrange
      when(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: testVerifiedById,
        completedAt: testCompletedAt,
        verifiedAt: testVerifiedAt,
        clearVerification: false,
      )).thenAnswer((_) async => Right(tTask));

      // act
      final result = await usecase(UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: testVerifiedById,
        completedAt: testCompletedAt,
        verifiedAt: testVerifiedAt,
      ));

      // assert
      expect(result.isRight(), true);
      result.fold(
        (failure) => fail('Expected success but got failure: $failure'),
        (task) {
          expect(task.id, testTaskId);
          expect(task.status, TaskStatus.completed);
          expect(task.verifiedById, testVerifiedById);
          expect(task.completedAt, testCompletedAt);
          expect(task.verifiedAt, testVerifiedAt);
        },
      );

      verify(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: testVerifiedById,
        completedAt: testCompletedAt,
        verifiedAt: testVerifiedAt,
        clearVerification: false,
      ));
    });

    test('should return ValidationFailure when taskId is empty', () async {
      // act
      final result = await usecase(const UpdateTaskStatusParams(
        taskId: '',
        status: TaskStatus.completed,
      ));

      // assert
      expect(result.isLeft(), true);
      result.fold(
        (failure) {
          expect(failure, isA<ValidationFailure>());
          expect((failure as ValidationFailure).message, contains('Task ID'));
        },
        (task) => fail('Expected failure but got success'),
      );

      verifyNever(mockRepository.updateTaskStatus(
        taskId: '',
        status: TaskStatus.completed,
        verifiedById: null,
        completedAt: null,
        verifiedAt: null,
        clearVerification: false,
      ));
    });

    test(
        'should return ValidationFailure when completedAt is null for completed task',
        () async {
      // act
      final result = await usecase(const UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.completed,
        completedAt: null,
      ));

      // assert
      expect(result.isLeft(), true);
      result.fold(
        (failure) {
          expect(failure, isA<ValidationFailure>());
          expect(
              (failure as ValidationFailure).message, contains('Completed at'));
        },
        (task) => fail('Expected failure but got success'),
      );
    });

    test(
        'should return ValidationFailure when verifiedAt is null but verifiedById is provided',
        () async {
      // act
      final result = await usecase(UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: testVerifiedById,
        completedAt: testCompletedAt,
        verifiedAt: null,
      ));

      // assert
      expect(result.isLeft(), true);
      result.fold(
        (failure) {
          expect(failure, isA<ValidationFailure>());
          expect(
              (failure as ValidationFailure).message, contains('Verified at'));
        },
        (task) => fail('Expected failure but got success'),
      );
    });

    test('should successfully update task when clearing verification',
        () async {
      // arrange
      final unverifiedTask = tTask.copyWith(
        verifiedById: null,
        verifiedAt: null,
      );

      when(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: null,
        completedAt: testCompletedAt,
        verifiedAt: null,
        clearVerification: true,
      )).thenAnswer((_) async => Right(unverifiedTask));

      // act
      final result = await usecase(UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.completed,
        completedAt: testCompletedAt,
        clearVerification: true,
      ));

      // assert
      expect(result.isRight(), true);
      result.fold(
        (failure) => fail('Expected success but got failure: $failure'),
        (task) {
          expect(task.id, testTaskId);
          expect(task.status, TaskStatus.completed);
          expect(task.verifiedById, isNull);
          expect(task.verifiedAt, isNull);
          expect(task.completedAt, testCompletedAt);
        },
      );

      verify(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: null,
        completedAt: testCompletedAt,
        verifiedAt: null,
        clearVerification: true,
      ));
    });

    test('should handle marking task as pending', () async {
      // arrange
      final pendingTask = tTask.copyWith(
        status: TaskStatus.pending,
        completedAt: null,
        verifiedById: null,
        verifiedAt: null,
      );

      when(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.pending,
        verifiedById: null,
        completedAt: null,
        verifiedAt: null,
        clearVerification: false,
      )).thenAnswer((_) async => Right(pendingTask));

      // act
      final result = await usecase(const UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.pending,
      ));

      // assert
      expect(result.isRight(), true);
      result.fold(
        (failure) => fail('Expected success but got failure: $failure'),
        (task) {
          expect(task.status, TaskStatus.pending);
          expect(task.completedAt, isNull);
          expect(task.verifiedById, isNull);
          expect(task.verifiedAt, isNull);
        },
      );
    });

    test('should handle marking task as in progress', () async {
      // arrange
      final inProgressTask = tTask.copyWith(
        status: TaskStatus.inProgress,
        completedAt: null,
        verifiedById: null,
        verifiedAt: null,
      );

      when(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.inProgress,
        verifiedById: null,
        completedAt: null,
        verifiedAt: null,
        clearVerification: false,
      )).thenAnswer((_) async => Right(inProgressTask));

      // act
      final result = await usecase(const UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.inProgress,
      ));

      // assert
      expect(result.isRight(), true);
      result.fold(
        (failure) => fail('Expected success but got failure: $failure'),
        (task) {
          expect(task.status, TaskStatus.inProgress);
          expect(task.completedAt, isNull);
        },
      );
    });

    test('should return ServerFailure when repository throws exception',
        () async {
      // arrange
      when(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: null,
        completedAt: testCompletedAt,
        verifiedAt: null,
        clearVerification: false,
      )).thenAnswer(
          (_) async => const Left(ServerFailure(message: 'Database error')));

      // act
      final result = await usecase(UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.completed,
        completedAt: testCompletedAt,
      ));

      // assert
      expect(result.isLeft(), true);
      result.fold(
        (failure) {
          expect(failure, isA<ServerFailure>());
          expect((failure as ServerFailure).message, 'Database error');
        },
        (task) => fail('Expected failure but got success'),
      );
    });

    test('should allow clearVerification even when verifiedById is null',
        () async {
      // This tests the fix for the unverify bug
      // arrange
      final unverifiedTask = tTask.copyWith(
        verifiedById: null,
        verifiedAt: null,
      );

      when(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: null,
        completedAt: testCompletedAt,
        verifiedAt: null,
        clearVerification: true,
      )).thenAnswer((_) async => Right(unverifiedTask));

      // act
      final result = await usecase(UpdateTaskStatusParams(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: null,
        completedAt: testCompletedAt,
        verifiedAt: null,
        clearVerification: true,
      ));

      // assert
      expect(result.isRight(), true);
      result.fold(
        (failure) => fail('Expected success but got failure: $failure'),
        (task) {
          expect(task.verifiedById, isNull);
          expect(task.verifiedAt, isNull);
        },
      );

      verify(mockRepository.updateTaskStatus(
        taskId: testTaskId,
        status: TaskStatus.completed,
        verifiedById: null,
        completedAt: testCompletedAt,
        verifiedAt: null,
        clearVerification: true,
      ));
    });
  });
}
